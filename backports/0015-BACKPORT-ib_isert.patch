From: Max Gurtovoy <maxg@mellanox.com>
Subject: [PATCH] BACKPORT: ib_isert

Change-Id: I1799473e4814f3b2e8d7ce73dad987d76a04be06
Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
---
 drivers/infiniband/ulp/isert/debian/changelog |   2 +-
 drivers/infiniband/ulp/isert/ib_isert.c       | 458 +++++++++++++++++++++++++-
 drivers/infiniband/ulp/isert/ib_isert.h       |  14 +
 drivers/target/iscsi/iscsi_target_core.h      |  73 ++++
 include/target/iscsi/iscsi_transport.h        |  35 ++
 5 files changed, 568 insertions(+), 14 deletions(-)

--- a/drivers/infiniband/ulp/isert/debian/changelog
+++ b/drivers/infiniband/ulp/isert/debian/changelog
@@ -1,4 +1,4 @@
-isert (0.0-0) unstable; urgency=low
+isert (1.0-0) unstable; urgency=low
 
   * Initial release.
 
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -26,7 +26,7 @@
 #include <rdma/rdma_cm.h>
 #include <target/target_core_base.h>
 #include <target/target_core_fabric.h>
-#include <target/iscsi/iscsi_transport.h>
+#include "target/iscsi/iscsi_transport.h"
 #include <linux/semaphore.h>
 
 #include "ib_isert.h"
@@ -36,7 +36,6 @@
 #define ISER_MAX_TX_CQ_LEN	(ISERT_QP_MAX_REQ_DTOS  * ISERT_MAX_CONN)
 #define ISER_MAX_CQ_LEN		(ISER_MAX_RX_CQ_LEN + ISER_MAX_TX_CQ_LEN + \
 				 ISERT_MAX_CONN)
-
 static int isert_debug_level;
 module_param_named(debug_level, isert_debug_level, int, 0644);
 MODULE_PARM_DESC(debug_level, "Enable debug tracing if > 0 (default:0)");
@@ -44,7 +43,14 @@ MODULE_PARM_DESC(debug_level, "Enable de
 static DEFINE_MUTEX(device_list_mutex);
 static LIST_HEAD(device_list);
 static struct workqueue_struct *isert_comp_wq;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+static DEFINE_MUTEX(connected_list_mutex);
+static LIST_HEAD(connected_list);
+#endif
 static struct workqueue_struct *isert_release_wq;
+#if !defined(CONFIG_COMPAT_RHEL_7_2) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+static struct kmem_cache *isert_cmd_cache;
+#endif
 
 static void
 isert_unmap_cmd(struct isert_cmd *isert_cmd, struct isert_conn *isert_conn);
@@ -70,8 +76,12 @@ static void isert_wait4flush(struct iser
 static inline bool
 isert_prot_cmd(struct isert_conn *conn, struct se_cmd *cmd)
 {
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	return (conn->pi_support &&
 		cmd->prot_op != TARGET_PROT_NORMAL);
+#else
+	return false;
+#endif
 }
 
 
@@ -496,6 +506,7 @@ isert_conn_free_fastreg_pool(struct iser
 			isert_conn->fr_pool_size - i);
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_create_pi_ctx(struct fast_reg_descriptor *desc,
 		    struct ib_device *device,
@@ -555,6 +566,7 @@ err_pi_ctx:
 
 	return ret;
 }
+#endif
 
 static int
 isert_create_fr_desc(struct ib_device *ib_device, struct ib_pd *pd,
@@ -648,6 +660,9 @@ isert_init_conn(struct isert_conn *isert
 	spin_lock_init(&isert_conn->pool_lock);
 	INIT_LIST_HEAD(&isert_conn->fr_pool);
 	INIT_WORK(&isert_conn->release_work, isert_release_work);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	INIT_LIST_HEAD(&isert_conn->conn_node);
+#endif
 }
 
 static void
@@ -746,11 +761,14 @@ static int
 isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 {
 	struct isert_np *isert_np = cma_id->context;
+#if defined(CONFIG_COMPAT_RHEL_7_1) || defined(CONFIG_COMPAT_SLES_12) || defined(CONFIG_COMPAT_FBK_16) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	struct iscsi_np *np = isert_np->np;
+#endif
 	struct isert_conn *isert_conn;
 	struct isert_device *device;
 	int ret = 0;
 
+#if defined(CONFIG_COMPAT_RHEL_7_1) || defined(CONFIG_COMPAT_SLES_12) || defined(CONFIG_COMPAT_FBK_16) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	spin_lock_bh(&np->np_thread_lock);
 	if (!np->enabled) {
 		spin_unlock_bh(&np->np_thread_lock);
@@ -759,6 +777,7 @@ isert_connect_request(struct rdma_cm_id
 	}
 	spin_unlock_bh(&np->np_thread_lock);
 
+#endif
 	isert_dbg("cma_id: %p, portal: %p\n",
 		 cma_id, cma_id->context);
 
@@ -822,6 +841,11 @@ isert_connect_release(struct isert_conn
 
 	BUG_ON(!device);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	mutex_lock(&connected_list_mutex);
+	list_del_init(&isert_conn->conn_node);
+	mutex_unlock(&connected_list_mutex);
+#endif
 	if (device->use_fastreg)
 		isert_conn_free_fastreg_pool(isert_conn);
 
@@ -1311,13 +1335,33 @@ isert_rx_login_req(struct isert_conn *is
 		  MAX_KEY_VALUE_PAIRS);
 	memcpy(login->req_buf, &rx_desc->data[0], size);
 
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	if (login->first_request) {
 		complete(&isert_conn->login_comp);
 		return;
 	}
 	schedule_delayed_work(&conn->login_work, 0);
+#else
+	complete(&isert_conn->login_comp);
+#endif
+}
+
+#if !defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+static void
+isert_release_cmd(struct iscsi_cmd *cmd)
+{
+	struct isert_cmd *isert_cmd = container_of(cmd, struct isert_cmd,
+                                iscsi_cmd);
+	pr_debug("Entering isert_release_cmd %p >>>>>>>>>>>>>>>.\n", isert_cmd);
+
+	kfree(cmd->buf_ptr);
+	kfree(cmd->tmr_req);
+
+	kmem_cache_free(isert_cmd_cache, isert_cmd);
 }
+#endif
 
+#if defined(CONFIG_COMPAT_ALLOCATE_CMD) || defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 static struct iscsi_cmd
 *isert_allocate_cmd(struct iscsi_conn *conn, struct iser_rx_desc *rx_desc)
 {
@@ -1337,6 +1381,44 @@ static struct iscsi_cmd
 
 	return cmd;
 }
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+static struct iscsi_cmd
+*isert_allocate_cmd(struct iscsi_conn *conn, struct iser_rx_desc *rx_desc, gfp_t gfp)
+{
+	struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+	struct isert_cmd *isert_cmd;
+	struct iscsi_cmd *cmd;
+
+	cmd = iscsit_allocate_cmd(conn, gfp);
+	if (!cmd) {
+		isert_err("Unable to allocate iscsi_cmd + isert_cmd\n");
+		return NULL;
+	}
+	isert_cmd = iscsit_priv_cmd(cmd);
+	isert_cmd->conn = isert_conn;
+	isert_cmd->iscsi_cmd = cmd;
+	isert_cmd->rx_desc = rx_desc;
+
+	return cmd;
+}
+#else
+static struct iscsi_cmd
+*isert_alloc_cmd(struct iscsi_conn *conn, gfp_t gfp)
+{
+        struct isert_conn *isert_conn = (struct isert_conn *)conn->context;
+        struct isert_cmd *isert_cmd;
+
+        isert_cmd = kmem_cache_zalloc(isert_cmd_cache, gfp);
+        if (!isert_cmd) {
+                pr_err("Unable to allocate isert_cmd\n");
+                return NULL;
+        }
+        isert_cmd->conn = isert_conn;
+        isert_cmd->iscsi_cmd.release_cmd = &isert_release_cmd;
+
+        return &isert_cmd->iscsi_cmd;
+}
+#endif
 
 static int
 isert_handle_scsi_cmd(struct isert_conn *isert_conn,
@@ -1402,7 +1484,11 @@ sequence_cmd:
 	if (!rc && dump_payload == false && unsol_data)
 		iscsit_set_unsoliticed_dataout(cmd);
 	else if (dump_payload && imm_data)
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(4,1,0) && !defined(CONFIG_COMPAT_RHEL_7_3))
+		target_put_sess_cmd(conn->sess->se_sess, &cmd->se_cmd);
+#else
 		target_put_sess_cmd(&cmd->se_cmd);
+#endif
 
 	return 0;
 }
@@ -1471,7 +1557,7 @@ isert_handle_iscsi_dataout(struct isert_
 	}
 	return 0;
 }
-
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static int
 isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		     struct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,
@@ -1490,7 +1576,28 @@ isert_handle_nop_out(struct isert_conn *
 
 	return iscsit_process_nop_out(conn, cmd, hdr);
 }
+#elif defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+static int
+isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+		     struct iser_rx_desc *rx_desc, unsigned char *buf)
+{
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+	struct iscsi_conn *conn = isert_conn->conn;
+	struct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;
+	int rc;
+
+	rc = iscsit_setup_nop_out(conn, cmd, hdr);
+	if (rc < 0)
+		return rc;
+	/*
+	 * FIXME: Add support for NOPOUT payload using unsolicited RDMA payload
+	 */
+
+	return iscsit_process_nop_out(conn, cmd, hdr);
+}
+#endif
 
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static int
 isert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		      struct iscsi_cmd *cmd, struct iser_rx_desc *rx_desc,
@@ -1519,6 +1626,35 @@ isert_handle_text_cmd(struct isert_conn
 
 	return iscsit_process_text_cmd(conn, cmd, hdr);
 }
+#elif defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+static int
+isert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+		      struct iser_rx_desc *rx_desc,
+		      struct iscsi_text *hdr)
+{
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+	struct iscsi_conn *conn = isert_conn->conn;
+	u32 payload_length = ntoh24(hdr->dlength);
+	int rc;
+	unsigned char *text_in;
+
+	rc = iscsit_setup_text_cmd(conn, cmd, hdr);
+	if (rc < 0)
+		return rc;
+
+	text_in = kzalloc(payload_length, GFP_KERNEL);
+	if (!text_in) {
+		isert_err("Unable to allocate text_in of payload_length: %u\n",
+			  payload_length);
+		return -ENOMEM;
+	}
+	cmd->text_in_ptr = text_in;
+
+	memcpy(cmd->text_in_ptr, &rx_desc->data[0], payload_length);
+
+	return iscsit_process_text_cmd(conn, cmd, hdr);
+}
+#endif
 
 static int
 isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
@@ -1541,11 +1677,21 @@ isert_rx_opcode(struct isert_conn *isert
 
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
+#if defined(CONFIG_COMPAT_ALLOCATE_CMD) || defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, rx_desc, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
-
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
+#else
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+		isert_cmd->rx_desc = rx_desc;
+#endif
 		isert_cmd->read_stag = read_stag;
 		isert_cmd->read_va = read_va;
 		isert_cmd->write_stag = write_stag;
@@ -1556,20 +1702,44 @@ isert_rx_opcode(struct isert_conn *isert
 					rx_desc, (unsigned char *)hdr);
 		break;
 	case ISCSI_OP_NOOP_OUT:
+#if defined(CONFIG_COMPAT_ALLOCATE_CMD) || defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, rx_desc, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
-
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
+#else
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+                isert_cmd->rx_desc = rx_desc;
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		ret = isert_handle_nop_out(isert_conn, isert_cmd, cmd,
 					   rx_desc, (unsigned char *)hdr);
+#elif defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+		ret = isert_handle_nop_out(isert_conn, isert_cmd,
+					   rx_desc, (unsigned char *)hdr);
+#else
+		ret = iscsit_handle_nop_out(conn, cmd, (unsigned char *)hdr);
+
+#endif
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		ret = isert_handle_iscsi_dataout(isert_conn, rx_desc,
 						(unsigned char *)hdr);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
+#if defined(CONFIG_COMPAT_ALLOCATE_CMD) || defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, rx_desc, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
@@ -1577,23 +1747,48 @@ isert_rx_opcode(struct isert_conn *isert
 						(unsigned char *)hdr);
 		break;
 	case ISCSI_OP_LOGOUT:
+#if defined(CONFIG_COMPAT_ALLOCATE_CMD) || defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
 		cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, rx_desc, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
+#if !defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+                isert_cmd->rx_desc = rx_desc;
+#endif
 
 		ret = iscsit_handle_logout_cmd(conn, cmd, (unsigned char *)hdr);
 		break;
 	case ISCSI_OP_TEXT:
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
 		if (be32_to_cpu(hdr->ttt) != 0xFFFFFFFF)
 			cmd = iscsit_find_cmd_from_itt(conn, hdr->itt);
 		else
 			cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_SLES_12) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
+		cmd = isert_allocate_cmd(conn, rx_desc);
+#elif defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		cmd = isert_allocate_cmd(conn, rx_desc, GFP_KERNEL);
+#else
+		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+#endif
 		if (!cmd)
 			break;
 
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		isert_cmd = iscsit_priv_cmd(cmd);
 		ret = isert_handle_text_cmd(isert_conn, isert_cmd, cmd,
 					    rx_desc, (struct iscsi_text *)hdr);
+#elif defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+		isert_cmd->rx_desc = rx_desc;
+		ret = isert_handle_text_cmd(isert_conn, isert_cmd,
+					    rx_desc, (struct iscsi_text *)hdr);
+#endif
 		break;
 	default:
 		isert_err("Got unknown iSCSI OpCode: 0x%02x\n", opcode);
@@ -1791,12 +1986,17 @@ isert_unreg_rdma(struct isert_cmd *isert
 static void
 isert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct iscsi_conn *conn = isert_conn->conn;
 	struct isert_device *device = isert_conn->device;
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
 	struct iscsi_text_rsp *hdr;
-
+#endif
 	isert_dbg("Cmd %p\n", isert_cmd);
 
 	switch (cmd->iscsi_opcode) {
@@ -1816,7 +2016,12 @@ isert_put_cmd(struct isert_cmd *isert_cm
 			 */
 			if (comp_err &&
 			    cmd->se_cmd.t_state == TRANSPORT_WRITE_PENDING) {
-				target_put_sess_cmd(&cmd->se_cmd);
+				struct se_cmd *se_cmd = &cmd->se_cmd;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(4,1,0) && !defined(CONFIG_COMPAT_RHEL_7_3))
+				target_put_sess_cmd(se_cmd->se_sess, se_cmd);
+#else
+				target_put_sess_cmd(se_cmd);
+#endif
 			}
 		}
 
@@ -1834,11 +2039,12 @@ isert_put_cmd(struct isert_cmd *isert_cm
 	case ISCSI_OP_REJECT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_TEXT:
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
 		hdr = (struct iscsi_text_rsp *)&isert_cmd->tx_desc.iscsi_header;
 		/* If the continue bit is on, keep the command alive */
 		if (hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)
 			break;
-
+#endif
 		spin_lock_bh(&conn->cmd_lock);
 		if (!list_empty(&cmd->i_conn_node))
 			list_del_init(&cmd->i_conn_node);
@@ -1859,7 +2065,11 @@ isert_put_cmd(struct isert_cmd *isert_cm
 		 * Fall-through
 		 */
 	default:
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 		iscsit_release_cmd(cmd);
+#else
+		isert_release_cmd(cmd);
+#endif
 		break;
 	}
 }
@@ -1890,6 +2100,7 @@ isert_completion_put(struct iser_tx_desc
 	isert_put_cmd(isert_cmd, comp_err);
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)
 {
@@ -1933,16 +2144,22 @@ isert_check_pi_status(struct se_cmd *se_
 fail_mr_status:
 	return ret;
 }
+#endif
 
 static void
 isert_completion_rdma_write(struct iser_tx_desc *tx_desc,
 			    struct isert_cmd *isert_cmd)
 {
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
-	struct se_cmd *se_cmd = &cmd->se_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct isert_device *device = isert_conn->device;
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
+	struct se_cmd *se_cmd = &cmd->se_cmd;
 	int ret = 0;
 
 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
@@ -1950,14 +2167,19 @@ isert_completion_rdma_write(struct iser_
 					    wr->fr_desc->pi_ctx->sig_mr);
 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
 	}
+#endif
 
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
 	wr->send_wr_num = 0;
+#if defined(CONFIG_COMPAT_SIGNATURE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	if (ret)
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd->pi_err, 0);
 	else
 		isert_put_response(isert_conn->conn, cmd);
+#else
+	isert_put_response(isert_conn->conn, cmd);
+#endif
 }
 
 static void
@@ -1965,10 +2187,15 @@ isert_completion_rdma_read(struct iser_t
 			   struct isert_cmd *isert_cmd)
 {
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct se_cmd *se_cmd = &cmd->se_cmd;
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct isert_device *device = isert_conn->device;
+#if defined(CONFIG_COMPAT_SIGNATURE)|| (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	int ret = 0;
 
 	if (wr->fr_desc && wr->fr_desc->ind & ISERT_PROTECTED) {
@@ -1976,6 +2203,7 @@ isert_completion_rdma_read(struct iser_t
 					    wr->fr_desc->pi_ctx->sig_mr);
 		wr->fr_desc->ind &= ~ISERT_PROTECTED;
 	}
+#endif
 
 	iscsit_stop_dataout_timer(cmd);
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
@@ -1988,13 +2216,21 @@ isert_completion_rdma_read(struct iser_t
 	cmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;
 	spin_unlock_bh(&cmd->istate_lock);
 
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	if (ret) {
-		target_put_sess_cmd(se_cmd);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(4,1,0) && !defined(CONFIG_COMPAT_RHEL_7_3))
+		target_put_sess_cmd(se_cmd->se_sess, &cmd->se_cmd);
+#else
+		target_put_sess_cmd(&cmd->se_cmd);
+#endif
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd->pi_err, 0);
 	} else {
 		target_execute_cmd(se_cmd);
 	}
+#else
+	target_execute_cmd(se_cmd);
+#endif
 }
 
 static void
@@ -2004,8 +2240,11 @@ isert_do_control_comp(struct work_struct
 			struct isert_cmd, comp_work);
 	struct isert_conn *isert_conn = isert_cmd->conn;
 	struct ib_device *ib_dev = isert_conn->cm_id->device;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
-
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	isert_dbg("Cmd %p i_state %d\n", isert_cmd, cmd->i_state);
 
 	switch (cmd->i_state) {
@@ -2033,7 +2272,11 @@ isert_response_completion(struct iser_tx
 			  struct isert_conn *isert_conn,
 			  struct ib_device *ib_dev)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 
 	if (cmd->i_state == ISTATE_SEND_TASKMGTRSP ||
 	    cmd->i_state == ISTATE_SEND_LOGOUTRSP ||
@@ -2210,7 +2453,12 @@ isert_post_response(struct isert_conn *i
 static int
 isert_put_response(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)
@@ -2256,10 +2504,16 @@ isert_put_response(struct iscsi_conn *co
 	return isert_post_response(isert_conn, isert_cmd);
 }
 
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 static void
 isert_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct isert_device *device = isert_conn->device;
 
@@ -2273,11 +2527,14 @@ isert_aborted_task(struct iscsi_conn *co
 
 	device->unreg_rdma_mem(isert_cmd, isert_conn);
 }
+#endif
 
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 static enum target_prot_op
 isert_get_sup_prot_ops(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	struct isert_device *device = isert_conn->device;
 
 	if (conn->tpg->tpg_attrib.t10_pi) {
@@ -2287,18 +2544,25 @@ isert_get_sup_prot_ops(struct iscsi_conn
 			return TARGET_PROT_ALL;
 		}
 	}
+#endif
 
 	isert_info("conn %p PI offload disabled\n", isert_conn);
 	isert_conn->pi_support = false;
 
 	return TARGET_PROT_NORMAL;
 }
+#endif
 
 static int
 isert_put_nopin(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
 		bool nopout_response)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2317,7 +2581,12 @@ isert_put_nopin(struct iscsi_cmd *cmd, s
 static int
 isert_put_logout_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2335,7 +2604,12 @@ isert_put_logout_rsp(struct iscsi_cmd *c
 static int
 isert_put_tm_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 
@@ -2353,7 +2627,12 @@ isert_put_tm_rsp(struct iscsi_cmd *cmd,
 static int
 isert_put_reject(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct isert_device *device = isert_conn->device;
@@ -2383,10 +2662,16 @@ isert_put_reject(struct iscsi_cmd *cmd,
 	return isert_post_response(isert_conn, isert_cmd);
 }
 
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 static int
 isert_put_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;
 	struct iscsi_text_rsp *hdr =
@@ -2423,13 +2708,18 @@ isert_put_text_rsp(struct iscsi_cmd *cmd
 
 	return isert_post_response(isert_conn, isert_cmd);
 }
+#endif
 
 static int
 isert_build_rdma_wr(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
 		    struct ib_sge *ib_sge, struct ib_send_wr *send_wr,
 		    u32 data_left, u32 offset)
 {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd *cmd = isert_cmd->iscsi_cmd;
+#else
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+#endif
 	struct scatterlist *sg_start, *tmp_sg;
 	struct isert_device *device = isert_conn->device;
 	struct ib_device *ib_dev = device->ib_device;
@@ -2480,7 +2770,12 @@ isert_map_rdma(struct iscsi_conn *conn,
 	       struct isert_rdma_wr *wr)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct isert_data_buf *data = &wr->data;
 	struct ib_send_wr *send_wr;
@@ -2695,6 +2990,7 @@ isert_fast_reg_mr(struct isert_conn *ise
 	return ret;
 }
 
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static inline void
 isert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs,
 		     struct ib_sig_domain *domain)
@@ -2715,7 +3011,9 @@ isert_set_dif_domain(struct se_cmd *se_c
 	    se_cmd->prot_type == TARGET_DIF_TYPE2_PROT)
 		domain->sig.dif.ref_remap = true;
 };
+#endif
 
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 static int
 isert_set_sig_attrs(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs)
 {
@@ -2874,13 +3172,19 @@ unmap_prot_cmd:
 
 	return ret;
 }
+#endif
 
 static int
 isert_reg_rdma(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 	       struct isert_rdma_wr *wr)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_conn *isert_conn = conn->context;
 	struct fast_reg_descriptor *fr_desc = NULL;
 	struct ib_send_wr *send_wr;
@@ -2913,9 +3217,11 @@ isert_reg_rdma(struct iscsi_conn *conn,
 		goto unmap_cmd;
 
 	if (isert_prot_cmd(isert_conn, se_cmd)) {
+#if defined(CONFIG_COMPAT_SIGNATURE) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 		ret = isert_handle_prot_cmd(isert_conn, isert_cmd, wr);
 		if (ret)
 			goto unmap_cmd;
+#endif
 
 		ib_sg = &wr->ib_sg[SIG];
 	} else {
@@ -2963,7 +3269,12 @@ static int
 isert_put_datain(struct iscsi_conn *conn, struct iscsi_cmd *cmd)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 	struct isert_conn *isert_conn = conn->context;
 	struct isert_device *device = isert_conn->device;
@@ -3018,7 +3329,12 @@ static int
 isert_get_dataout(struct iscsi_conn *conn, struct iscsi_cmd *cmd, bool recovery)
 {
 	struct se_cmd *se_cmd = &cmd->se_cmd;
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+	struct isert_cmd *isert_cmd = container_of(cmd,
+					struct isert_cmd, iscsi_cmd);
+#endif
 	struct isert_rdma_wr *wr = &isert_cmd->rdma_wr;
 	struct isert_conn *isert_conn = conn->context;
 	struct isert_device *device = isert_conn->device;
@@ -3048,7 +3364,12 @@ static int
 isert_immediate_queue(struct iscsi_conn *conn, struct iscsi_cmd *cmd, int state)
 {
 	int ret = 0;
-	struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+	struct isert_cmd *isert_cmd;
+	#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+		isert_cmd = iscsit_priv_cmd(cmd);
+	#else
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+	#endif
 
 	switch (state) {
 	case ISTATE_REMOVE:
@@ -3090,9 +3411,11 @@ isert_response_queue(struct iscsi_conn *
 	case ISTATE_SEND_REJECT:
 		ret = isert_put_reject(cmd, conn);
 		break;
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 	case ISTATE_SEND_TEXTRSP:
 		ret = isert_put_text_rsp(cmd, conn);
 		break;
+#endif
 	case ISTATE_SEND_STATUS:
 		/*
 		 * Special case for sending non GOOD SCSI status from TX thread
@@ -3262,11 +3585,39 @@ isert_set_conn_info(struct iscsi_np *np,
 {
 	struct rdma_cm_id *cm_id = isert_conn->cm_id;
 	struct rdma_route *cm_route = &cm_id->route;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0) && !defined(CONFIG_COMPAT_RHEL_7_3))
+	struct sockaddr_in *sock_in;
+	struct sockaddr_in6 *sock_in6;
+#endif
 
 	conn->login_family = np->np_sockaddr.ss_family;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0) && !defined(CONFIG_COMPAT_RHEL_7_3))
+	if (np->np_sockaddr.ss_family == AF_INET6) {
+		sock_in6 = (struct sockaddr_in6 *)&cm_route->addr.dst_addr;
+		snprintf(conn->login_ip, sizeof(conn->login_ip), "%pI6c",
+			 &sock_in6->sin6_addr.in6_u);
+		conn->login_port = ntohs(sock_in6->sin6_port);
+
+		sock_in6 = (struct sockaddr_in6 *)&cm_route->addr.src_addr;
+		snprintf(conn->local_ip, sizeof(conn->local_ip), "%pI6c",
+			 &sock_in6->sin6_addr.in6_u);
+		conn->local_port = ntohs(sock_in6->sin6_port);
+	} else {
+		sock_in = (struct sockaddr_in *)&cm_route->addr.dst_addr;
+		sprintf(conn->login_ip, "%pI4",
+			&sock_in->sin_addr.s_addr);
+		conn->login_port = ntohs(sock_in->sin_port);
+
+		sock_in = (struct sockaddr_in *)&cm_route->addr.src_addr;
+		sprintf(conn->local_ip, "%pI4",
+			&sock_in->sin_addr.s_addr);
+		conn->local_port = ntohs(sock_in->sin_port);
+	}
+#else
 	conn->login_sockaddr = cm_route->addr.dst_addr;
 	conn->local_sockaddr = cm_route->addr.src_addr;
+#endif
 }
 
 static int
@@ -3303,6 +3654,11 @@ accept_wait:
 				      struct isert_conn, node);
 	list_del_init(&isert_conn->node);
 	mutex_unlock(&isert_np->mutex);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	mutex_lock(&connected_list_mutex);
+	list_add_tail(&isert_conn->conn_node, &connected_list);
+	mutex_unlock(&connected_list_mutex);
+#endif
 
 	conn->context = isert_conn;
 	isert_conn->conn = conn;
@@ -3439,13 +3795,18 @@ isert_put_unsol_pending_cmds(struct iscs
 	list_for_each_entry_safe(cmd, tmp, &drop_cmd_list, i_conn_node) {
 		list_del_init(&cmd->i_conn_node);
 		if (cmd->i_state != ISTATE_REMOVE) {
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 			struct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);
+#else
+			struct isert_cmd *isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+#endif
 
 			isert_info("conn %p dropping cmd %p\n", conn, cmd);
 			isert_put_cmd(isert_cmd, true);
 		}
 	}
 }
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 static void isert_wait_conn(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
@@ -3463,13 +3824,36 @@ static void isert_wait_conn(struct iscsi
 
 	queue_work(isert_release_wq, &isert_conn->release_work);
 }
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 
 static void isert_free_conn(struct iscsi_conn *conn)
 {
 	struct isert_conn *isert_conn = conn->context;
 
+#if !defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
+	mutex_lock(&isert_conn->mutex);
+	/*
+	 * Only wait for conn_wait_comp_err if the isert_conn made it
+	 * into full feature phase..
+	 */
+	if (isert_conn->state == ISER_CONN_INIT) {
+		mutex_unlock(&isert_conn->mutex);
+		goto out;
+	}
+	isert_conn_terminate(isert_conn);
+	mutex_unlock(&isert_conn->mutex);
+
+	isert_wait4flush(isert_conn);
+	isert_put_unsol_pending_cmds(conn);
+	isert_wait4cmds(conn);
+	isert_wait4logout(isert_conn);
+
+	queue_work(isert_release_wq, &isert_conn->release_work);
+out:
+#else
 	/* post another beacon request to make sure we are last indeed */
 	isert_wait4flush(isert_conn);
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 
 	isert_put_conn(isert_conn);
 }
@@ -3477,13 +3861,20 @@ static void isert_free_conn(struct iscsi
 static struct iscsit_transport iser_target_transport = {
 	.name			= "IB/iSER",
 	.transport_type		= ISCSI_INFINIBAND,
+#if defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	.priv_size		= sizeof(struct isert_cmd),
+#endif
 	.owner			= THIS_MODULE,
 	.iscsit_setup_np	= isert_setup_np,
 	.iscsit_accept_np	= isert_accept_np,
 	.iscsit_free_np		= isert_free_np,
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 	.iscsit_wait_conn	= isert_wait_conn,
-	.iscsit_free_conn	= isert_free_conn,
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
+	.iscsit_free_conn       = isert_free_conn,
+#if !defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	.iscsit_alloc_cmd       = isert_alloc_cmd,
+#endif
 	.iscsit_get_login_rx	= isert_get_login_rx,
 	.iscsit_put_login_tx	= isert_put_login_tx,
 	.iscsit_immediate_queue	= isert_immediate_queue,
@@ -3491,8 +3882,12 @@ static struct iscsit_transport iser_targ
 	.iscsit_get_dataout	= isert_get_dataout,
 	.iscsit_queue_data_in	= isert_put_datain,
 	.iscsit_queue_status	= isert_put_response,
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 	.iscsit_aborted_task	= isert_aborted_task,
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	.iscsit_get_sup_prot_ops = isert_get_sup_prot_ops,
+#endif
 };
 
 static int __init isert_init(void)
@@ -3515,11 +3910,26 @@ static int __init isert_init(void)
 		goto destroy_comp_wq;
 	}
 
+#if !defined(CONFIG_COMPAT_RHEL_7_2) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+        isert_cmd_cache = kmem_cache_create("isert_cmd_cache",
+                        sizeof(struct isert_cmd), __alignof__(struct isert_cmd),
+                        0, NULL);
+        if (!isert_cmd_cache) {
+                pr_err("Unable to create isert_cmd_cache\n");
+                ret = -ENOMEM;
+                goto destroy_release_wq;
+        }
+#endif
+
 	iscsit_register_transport(&iser_target_transport);
 	isert_info("iSER_TARGET[0] - Loaded iser_target_transport\n");
 
 	return 0;
 
+#if !defined(CONFIG_COMPAT_RHEL_7_2) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+destroy_release_wq:
+	destroy_workqueue(isert_release_wq);
+#endif
 destroy_comp_wq:
 	destroy_workqueue(isert_comp_wq);
 
@@ -3528,11 +3938,33 @@ destroy_comp_wq:
 
 static void __exit isert_exit(void)
 {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	struct isert_conn *isert_conn;
+	struct isert_conn *tmp_conn;
+#endif
+
+#if !defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	LIST_HEAD(release_list);
+#endif
+
+#if !defined(CONFIG_COMPAT_RHEL_7_2) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	kmem_cache_destroy(isert_cmd_cache);
+#endif
 	flush_scheduled_work();
 	destroy_workqueue(isert_release_wq);
 	destroy_workqueue(isert_comp_wq);
 	iscsit_unregister_transport(&iser_target_transport);
+
 	isert_info("iSER_TARGET[0] - Released iser_target_transport\n");
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+	list_for_each_entry_safe(isert_conn, tmp_conn, &connected_list, conn_node)
+		list_add_tail(&isert_conn->release_node, &release_list);
+
+	list_for_each_entry(isert_conn, &release_list, release_node)
+		isert_connect_release(isert_conn);
+	isert_info("iSER_TARGET[0] - Exit module\n");
+#endif
 }
 
 MODULE_DESCRIPTION("iSER-Target for mainline target infrastructure");
--- a/drivers/infiniband/ulp/isert/ib_isert.h
+++ b/drivers/infiniband/ulp/isert/ib_isert.h
@@ -69,6 +69,12 @@
 #define ISER_FASTREG_LI_WRID		0xffffffffffffffffULL
 #define ISER_BEACON_WRID               0xfffffffffffffffeULL
 
+#if defined(CONFIG_COMPAT_RHEL_7_2)
+#define CONFIG_COMPAT_ALLOCATE_CMD 1
+#define CONFIG_COMPAT_ISCSIT_PRIV_CMD 1
+#define CONFIG_COMPAT_SIGNATURE 1
+#endif
+
 enum isert_desc_type {
 	ISCSI_TX_CONTROL,
 	ISCSI_TX_DATAIN
@@ -174,7 +180,11 @@ struct isert_cmd {
 	u32			write_va_off;
 	u32			rdma_wr_num;
 	struct isert_conn	*conn;
+#if defined(CONFIG_COMPAT_RHEL_7_2) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_cmd	*iscsi_cmd;
+#else
+	struct iscsi_cmd	iscsi_cmd;
+#endif
 	struct iser_tx_desc	tx_desc;
 	struct iser_rx_desc	*rx_desc;
 	struct isert_rdma_wr	rdma_wr;
@@ -217,6 +227,10 @@ struct isert_conn {
 	struct ib_recv_wr       beacon;
 	bool                    logout_posted;
 	bool                    snd_w_inv;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(4,0,0))
+	struct list_head	conn_node;
+	struct list_head	release_node;
+#endif
 };
 
 #define ISERT_MAX_CQ 64
--- a/drivers/target/iscsi/iscsi_target_core.h
+++ b/drivers/target/iscsi/iscsi_target_core.h
@@ -37,6 +37,9 @@
 #define NA_RANDOM_DATAIN_PDU_OFFSETS	0
 #define NA_RANDOM_DATAIN_SEQ_OFFSETS	0
 #define NA_RANDOM_R2T_OFFSETS		0
+#define NA_DEFAULT_ERL			0
+#define NA_DEFAULT_ERL_MAX		2
+#define NA_DEFAULT_ERL_MIN		0
 
 /* struct iscsi_tpg_attrib sanity values */
 #define TA_AUTHENTICATION		1
@@ -47,7 +50,11 @@
 #define TA_NETIF_TIMEOUT_MAX		15
 #define TA_NETIF_TIMEOUT_MIN		2
 #define TA_GENERATE_NODE_ACLS		0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+#define TA_DEFAULT_CMDSN_DEPTH		16
+#else
 #define TA_DEFAULT_CMDSN_DEPTH		64
+#endif
 #define TA_DEFAULT_CMDSN_DEPTH_MAX	512
 #define TA_DEFAULT_CMDSN_DEPTH_MIN	1
 #define TA_CACHE_DYNAMIC_ACLS		0
@@ -434,8 +441,10 @@ struct iscsi_cmd {
 	u32			tx_size;
 	/* Buffer used for various purposes */
 	void			*buf_ptr;
+#if defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 	/* Used by SendTargets=[iqn.,eui.] discovery */
 	void			*text_in_ptr;
+#endif
 	/* See include/linux/dma-mapping.h */
 	enum dma_data_direction	data_direction;
 	/* iSCSI PDU Header + CRC */
@@ -493,6 +502,9 @@ struct iscsi_cmd {
 	u32			first_data_sg_off;
 	u32			kmapped_nents;
 	sense_reason_t		sense_reason;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	void (*release_cmd)(struct iscsi_cmd *);
+#endif
 }  ____cacheline_aligned;
 
 struct iscsi_tmr_req {
@@ -535,6 +547,10 @@ struct iscsi_conn {
 	u32			of_marker;
 	/* Used for calculating OFMarker offset to next PDU */
 	u32			of_marker_offset;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+	/* Complete Bad PDU for sending reject */
+	unsigned char		bad_hdr[ISCSI_HDR_LEN];
+#endif
 #define IPV6_ADDRESS_SPACE				48
 	unsigned char		login_ip[IPV6_ADDRESS_SPACE];
 	unsigned char		local_ip[IPV6_ADDRESS_SPACE];
@@ -557,7 +573,12 @@ struct iscsi_conn {
 	struct completion	rx_half_close_comp;
 	/* socket used by this connection */
 	struct socket		*sock;
+#if defined(CONFIG_COMPAT_SLES_12_0) || defined(CONFIG_COMPAT_UBUNTU_14_4)
+	void                    (*orig_data_ready)(struct sock *, int);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	void			(*orig_data_ready)(struct sock *);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	void			(*orig_state_change)(struct sock *);
 #define LOGIN_FLAGS_READ_ACTIVE		1
 #define LOGIN_FLAGS_CLOSED		2
@@ -566,10 +587,13 @@ struct iscsi_conn {
 	struct delayed_work	login_work;
 	struct delayed_work	login_cleanup_work;
 	struct iscsi_login	*login;
+#endif
 	struct timer_list	nopin_timer;
 	struct timer_list	nopin_response_timer;
 	struct timer_list	transport_timer;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct task_struct	*login_kworker;
+#endif
 	/* Spinlock used for add/deleting cmd's from conn_cmd_list */
 	spinlock_t		cmd_lock;
 	spinlock_t		conn_usage_lock;
@@ -597,7 +621,9 @@ struct iscsi_conn {
 	void			*context;
 	struct iscsi_login_thread_s *login_thread;
 	struct iscsi_portal_group *tpg;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_tpg_np	*tpg_np;
+#endif
 	/* Pointer to parent session */
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn's threads */
@@ -651,13 +677,25 @@ struct iscsi_session {
 	/* Used for session reference counting */
 	int			session_usage_count;
 	int			session_waiting_on_uc;
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0))
 	atomic_long_t		cmd_pdus;
 	atomic_long_t		rsp_pdus;
 	atomic_long_t		tx_data_octets;
 	atomic_long_t		rx_data_octets;
 	atomic_long_t		conn_digest_errors;
 	atomic_long_t		conn_timeout_errors;
+#else
+	u32			cmd_pdus;
+	u32			rsp_pdus;
+	u64			tx_data_octets;
+	u64			rx_data_octets;
+	u32			conn_digest_errors;
+	u32			conn_timeout_errors;
+#endif
 	u64			creation_time;
+#if !defined(CONFIG_COMPAT_SLES_12_0) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0))
+	spinlock_t              session_stats_lock;
+#endif
 	/* Number of active connections */
 	atomic_t		nconn;
 	atomic_t		session_continuation;
@@ -695,7 +733,9 @@ struct iscsi_login {
 	u8 version_max;
 	u8 login_complete;
 	u8 login_failed;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	bool zero_tsih;
+#endif
 	char isid[6];
 	u32 cmd_sn;
 	itt_t init_task_tag;
@@ -708,7 +748,9 @@ struct iscsi_login {
 	char *req_buf;
 	char *rsp_buf;
 	struct iscsi_conn *conn;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct iscsi_np *np;
+#endif
 } ____cacheline_aligned;
 
 struct iscsi_node_attrib {
@@ -755,6 +797,11 @@ struct iscsi_node_acl {
 	struct se_node_acl	se_node_acl;
 };
 
+#define NODE_STAT_GRPS(nacl)	(&(nacl)->node_stat_grps)
+
+#define ISCSI_NODE_ATTRIB(t)	(&(t)->node_attrib)
+#define ISCSI_NODE_AUTH(t)	(&(t)->node_auth)
+
 struct iscsi_tpg_attrib {
 	u32			authentication;
 	u32			login_timeout;
@@ -764,9 +811,13 @@ struct iscsi_tpg_attrib {
 	u32			default_cmdsn_depth;
 	u32			demo_mode_write_protect;
 	u32			prod_mode_write_protect;
+#if defined(CONFIG_COMPAT_SLES_12_0) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,13,0))
 	u32			demo_mode_discovery;
 	u32			default_erl;
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	u8			t10_pi;
+#endif
 	struct iscsi_portal_group *tpg;
 };
 
@@ -775,7 +826,9 @@ struct iscsi_np {
 	int			np_ip_proto;
 	int			np_sock_type;
 	enum np_thread_state_table np_thread_state;
+#if defined(CONFIG_COMPAT_RHEL_7_1) || defined(CONFIG_COMPAT_SLES_12_0) || defined(CONFIG_COMPAT_FBK_16) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0))
 	bool                    enabled;
+#endif
 	enum iscsi_timer_flags_table np_login_timer_flags;
 	u32			np_exports;
 	enum np_flags_table	np_flags;
@@ -787,9 +840,15 @@ struct iscsi_np {
 	struct __kernel_sockaddr_storage np_sockaddr;
 	struct task_struct	*np_thread;
 	struct timer_list	np_login_timer;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	struct iscsi_portal_group *np_login_tpg;
+#endif
 	void			*np_context;
 	struct iscsit_transport *np_transport;
 	struct list_head	np_list;
+#if defined(CONFIG_COMPAT_SLES_12_0) || ((LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)))
+	struct iscsi_tpg_np	*tpg_np;
+#endif
 } ____cacheline_aligned;
 
 struct iscsi_tpg_np {
@@ -801,8 +860,10 @@ struct iscsi_tpg_np {
 	struct list_head	tpg_np_parent_list;
 	struct se_tpg_np	se_tpg_np;
 	spinlock_t		tpg_np_parent_lock;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct completion	tpg_np_comp;
 	struct kref		tpg_np_kref;
+#endif
 };
 
 struct iscsi_portal_group {
@@ -824,7 +885,11 @@ struct iscsi_portal_group {
 	spinlock_t		tpg_state_lock;
 	struct se_portal_group tpg_se_tpg;
 	struct mutex		tpg_access_lock;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	struct semaphore	np_login_sem;
+#else
+	struct mutex            np_login_lock;
+#endif
 	struct iscsi_tpg_attrib	tpg_attrib;
 	struct iscsi_node_auth	tpg_demo_auth;
 	/* Pointer to default list of iSCSI parameters for TPG */
@@ -834,6 +899,12 @@ struct iscsi_portal_group {
 	struct list_head	tpg_list;
 } ____cacheline_aligned;
 
+#define ISCSI_TPG_C(c)		((struct iscsi_portal_group *)(c)->tpg)
+#define ISCSI_TPG_LUN(c, l)  ((iscsi_tpg_list_t *)(c)->tpg->tpg_lun_list_t[l])
+#define ISCSI_TPG_S(s)		((struct iscsi_portal_group *)(s)->tpg)
+#define ISCSI_TPG_ATTRIB(t)	(&(t)->tpg_attrib)
+#define SE_TPG(tpg)		(&(tpg)->tpg_se_tpg)
+
 struct iscsi_wwn_stat_grps {
 	struct config_group	iscsi_stat_group;
 	struct config_group	iscsi_instance_group;
@@ -864,6 +935,8 @@ struct iscsi_tiqn {
 	struct iscsi_logout_stats    logout_stats;
 } ____cacheline_aligned;
 
+#define WWN_STAT_GRPS(tiqn)   (&(tiqn)->tiqn_stat_grps)
+
 struct iscsit_global {
 	/* In core shutdown */
 	u32			in_shutdown;
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@ -1,3 +1,6 @@
+#if defined(CONFIG_COMPAT_RHEL_7_2) || defined(CONFIG_COMPAT_SLES_12)
+#include_next <target/iscsi/iscsi_transport.h>
+#else
 #include <linux/module.h>
 #include <linux/list.h>
 #include "../../../drivers/target/iscsi/iscsi_target_core.h"
@@ -6,14 +9,21 @@ struct iscsit_transport {
 #define ISCSIT_TRANSPORT_NAME	16
 	char name[ISCSIT_TRANSPORT_NAME];
 	int transport_type;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 	int priv_size;
+#endif
 	struct module *owner;
 	struct list_head t_node;
 	int (*iscsit_setup_np)(struct iscsi_np *, struct __kernel_sockaddr_storage *);
 	int (*iscsit_accept_np)(struct iscsi_np *, struct iscsi_conn *);
 	void (*iscsit_free_np)(struct iscsi_np *);
+#if defined(CONFIG_COMPAT_ISCSIT_WAIT_CONN)
 	void (*iscsit_wait_conn)(struct iscsi_conn *);
+#endif /* CONFIG_COMPAT_ISCSIT_WAIT_CONN */
 	void (*iscsit_free_conn)(struct iscsi_conn *);
+#if !defined(CONFIG_COMPAT_ISCSIT_PRIV_CMD) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+	struct iscsi_cmd *(*iscsit_alloc_cmd)(struct iscsi_conn *, gfp_t);
+#endif
 	int (*iscsit_get_login_rx)(struct iscsi_conn *, struct iscsi_login *);
 	int (*iscsit_put_login_tx)(struct iscsi_conn *, struct iscsi_login *, u32);
 	int (*iscsit_immediate_queue)(struct iscsi_conn *, struct iscsi_cmd *, int);
@@ -21,14 +31,20 @@ struct iscsit_transport {
 	int (*iscsit_get_dataout)(struct iscsi_conn *, struct iscsi_cmd *, bool);
 	int (*iscsit_queue_data_in)(struct iscsi_conn *, struct iscsi_cmd *);
 	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
+#if defined(CONFIG_COMPAT_ISCSIT_ABORTED_TASK)
 	void (*iscsit_aborted_task)(struct iscsi_conn *, struct iscsi_cmd *);
+#endif
+#if defined(CONFIG_COMPAT_ISCSIT_GET_SUP_PROT_OPS)
 	enum target_prot_op (*iscsit_get_sup_prot_ops)(struct iscsi_conn *);
+#endif
 };
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 static inline void *iscsit_priv_cmd(struct iscsi_cmd *cmd)
 {
 	return (void *)(cmd + 1);
 }
+#endif
 
 /*
  * From iscsi_target_transport.c
@@ -42,6 +58,10 @@ extern void iscsit_put_transport(struct
 /*
  * From iscsi_target.c
  */
+#if !defined(CONFIG_COMPAT_FBK_16) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+extern int iscsit_add_reject_from_cmd(u8, int, int, unsigned char *,
+				struct iscsi_cmd *);
+#endif
 extern int iscsit_setup_scsi_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern void iscsit_set_unsoliticed_dataout(struct iscsi_cmd *);
@@ -51,27 +71,37 @@ extern int iscsit_check_dataout_hdr(stru
 				struct iscsi_cmd **);
 extern int iscsit_check_dataout_payload(struct iscsi_cmd *, struct iscsi_data *,
 				bool);
+#if !defined(CONFIG_COMPAT_RHEL_7_1) && (LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0))
+extern int iscsit_handle_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				unsigned char *);
+#endif
+#if defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_setup_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
 				struct iscsi_nopout *);
 extern int iscsit_process_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
 				struct iscsi_nopout *);
+#endif
 extern int iscsit_handle_logout_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern int iscsit_handle_task_mgt_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
+#if defined(CONFIG_COMPAT_RHEL_7_1) || (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_setup_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				 struct iscsi_text *);
 extern int iscsit_process_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				   struct iscsi_text *);
+#endif
 extern void iscsit_build_rsp_pdu(struct iscsi_cmd *, struct iscsi_conn *,
 				bool, struct iscsi_scsi_rsp *);
 extern void iscsit_build_nopin_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_nopin *, bool);
 extern void iscsit_build_task_mgt_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_tm_rsp *);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0))
 extern int iscsit_build_text_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_text_rsp *,
 				enum iscsit_transport_type);
+#endif
 extern void iscsit_build_reject(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_reject *);
 extern int iscsit_build_logout_rsp(struct iscsi_cmd *, struct iscsi_conn *,
@@ -101,4 +131,9 @@ extern int iscsit_tmr_post_handler(struc
 extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, int);
 extern int iscsit_sequence_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 			       unsigned char *, __be32);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
 extern void iscsit_release_cmd(struct iscsi_cmd *);
+#endif
+
+#endif /* RH7.2 SLES12 */
+
