From: Vladimir Sokolovsky <vlad@mellanox.com>
Subject: [PATCH] BACKPORT: ib_ipoib

Change-Id: I1cbf552ab22cc58ee734001a4ff3f07d9194a409
Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
---
 drivers/infiniband/ulp/ipoib/ipoib.h               |  20 ++-
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |   9 +-
 drivers/infiniband/ulp/ipoib/ipoib_ethtool.c       |  39 +++++
 drivers/infiniband/ulp/ipoib/ipoib_ib.c            |  12 +-
 drivers/infiniband/ulp/ipoib/ipoib_main.c          | 177 ++++++++++++++++++++-
 drivers/infiniband/ulp/ipoib/ipoib_multicast.c     |  15 ++
 drivers/infiniband/ulp/ipoib/ipoib_netlink.c       |  20 ++-
 .../ulp/ipoib/rss_tss/ipoib_ethtool_rss.c          |  22 ++-
 .../infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c    |  13 +-
 .../infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c  |  66 +++++++-
 drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h   |   3 +
 11 files changed, 379 insertions(+), 17 deletions(-)

--- a/drivers/infiniband/ulp/ipoib/ipoib.h
+++ b/drivers/infiniband/ulp/ipoib/ipoib.h
@@ -42,6 +42,7 @@
 #include <linux/kref.h>
 #include <linux/if_infiniband.h>
 #include <linux/mutex.h>
+#include <linux/ratelimit.h>
 
 #include <net/neighbour.h>
 #include <net/sch_generic.h>
@@ -52,7 +53,9 @@
 #include <rdma/ib_pack.h>
 #include <rdma/ib_sa.h>
 #include <linux/sched.h>
-
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+#include <linux/inet_lro.h>
+#endif
 /* constants */
 
 enum ipoib_flush_level {
@@ -121,7 +124,18 @@ enum {
 	IPOIB_NON_CHILD		  = 0,
 	IPOIB_LEGACY_CHILD	  = 1,
 	IPOIB_RTNL_CHILD	  = 2,
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	IPOIB_MAX_LRO_DESCRIPTORS = 8,
+	IPOIB_LRO_MAX_AGGR      = 64,
+#endif
+};
+
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+struct ipoib_lro {
+	struct net_lro_mgr lro_mgr;
+	struct net_lro_desc lro_desc[IPOIB_MAX_LRO_DESCRIPTORS];
 };
+#endif
 
 #define	IPOIB_OP_RECV   (1ul << 31)
 #ifdef CONFIG_INFINIBAND_IPOIB_CM
@@ -436,7 +450,9 @@ struct ipoib_dev_priv {
 	atomic_t tx_ring_ind;
 	unsigned max_send_sge;
 	bool sm_fullmember_sendonly_support;
-
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	struct ipoib_lro lro;
+#endif
 	/* Function pointers for RSS support */
 	struct ipoib_func_pointers fp;
 };
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -1493,7 +1493,11 @@ static void ipoib_cm_skb_reap(struct wor
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));
 #if IS_ENABLED(CONFIG_IPV6)
 		else if (skb->protocol == htons(ETH_P_IPV6))
+#ifdef HAVE_ICMPV6_SEND_4_PARAMS
 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
+#else
+			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu, priv->dev);
+#endif
 #endif
 		dev_kfree_skb_any(skb);
 
@@ -1512,8 +1516,11 @@ void ipoib_cm_skb_too_long(struct net_de
 	int e = skb_queue_empty(&priv->cm.skb_queue);
 
 	if (skb_dst(skb))
+#if defined HAVE_UPDATE_PMTU_4_PARAMS
 		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
-
+#else
+		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);
+#endif
 	skb_queue_tail(&priv->cm.skb_queue, skb);
 	if (e)
 		queue_work(priv->wq, &priv->cm.skb_task);
--- a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
@@ -299,6 +299,28 @@ static int ipoib_get_sset_count(struct n
 	return -EOPNOTSUPP;
 }
 
+#ifndef HAVE_NETDEV_HW_FEATURES
+#if defined(HAVE_GET_SET_FLAGS) && defined(CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+int ipoib_set_flags(struct net_device *dev, u32 data)
+{
+	struct ipoib_dev_priv *priv = netdev_priv(dev);
+	int hw_support_lro = 0;
+
+#ifdef HAVE_NETDEV_HW_FEATURES
+	hw_support_lro = priv->dev->hw_features & NETIF_F_RXCSUM;
+#else
+	hw_support_lro = priv->dev->features & NETIF_F_RXCSUM;
+#endif
+
+	if ((data & ETH_FLAG_LRO) && hw_support_lro)
+		dev->features |= NETIF_F_LRO;
+	else
+		dev->features &= ~NETIF_F_LRO;
+	return 0;
+}
+#endif
+#endif
+
 static const struct ethtool_ops ipoib_ethtool_ops = {
 	.get_drvinfo		= ipoib_get_drvinfo,
 	.get_coalesce		= ipoib_get_coalesce,
@@ -310,6 +332,23 @@ static const struct ethtool_ops ipoib_et
 	.get_sset_count		= ipoib_get_sset_count,
 	.set_ringparam		= ipoib_set_ring_param,
 	.get_ringparam		= ipoib_get_ring_param,
+
+/* IPoIB current code supports HW_FEATURES and doesn't
+ * support EXTENDED_HW_FEATURES. If support for EXTENDED_HW_FEATURES
+ * is added then this code and the set function should be masked
+ * with LEGACY_ETHTOOL_OPS.
+ */
+#ifndef HAVE_NETDEV_HW_FEATURES
+#ifdef HAVE_GET_SET_FLAGS
+#if defined (CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+	.set_flags		= ipoib_set_flags,
+#endif
+	.get_flags		= ethtool_op_get_flags,
+#endif
+#ifdef HAVE_GET_SET_TSO
+	.set_tso		= ethtool_op_set_tso,
+#endif
+#endif
 };
 
 void ipoib_set_ethtool_ops(struct net_device *dev)
--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c
@@ -297,8 +297,14 @@ static void ipoib_ib_handle_rx_wc(struct
 	if ((dev->features & NETIF_F_RXCSUM) &&
 			likely(wc->wc_flags & IB_WC_IP_CSUM_OK))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
-
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	if (dev->features & NETIF_F_LRO)
+		lro_receive_skb(&priv->lro.lro_mgr, skb, NULL);
+	else
+		netif_receive_skb(skb);
+#else
 	napi_gro_receive(&priv->recv_napi, skb);
+#endif
 
 repost:
 	if (unlikely(ipoib_ib_post_receive(dev, wr_id)))
@@ -521,6 +527,10 @@ poll_more:
 	}
 
 	if (done < budget) {
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		if (dev->features & NETIF_F_LRO)
+			lro_flush_all(&priv->lro.lro_mgr);
+#endif
 		napi_complete(napi);
 		if (unlikely(ib_req_notify_cq(priv->recv_cq,
 					      IB_CQ_NEXT_COMP |
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -103,7 +103,9 @@ static struct net_device *ipoib_get_net_
 		struct ib_device *dev, u8 port, u16 pkey,
 		const union ib_gid *gid, const struct sockaddr *addr,
 		void *client_data);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 static int ipoib_set_mac(struct net_device *dev, void *addr);
+#endif
 static int ipoib_get_hca_features(struct ipoib_dev_priv *priv,
 				  struct ib_device *hca);
 
@@ -204,6 +206,7 @@ void ipoib_uninit(struct net_device *dev
 	priv->fp.ipoib_dev_cleanup(dev);
 }
 
+#ifdef HAVE_NDO_FIX_FEATURES
 static netdev_features_t ipoib_fix_features(struct net_device *dev, netdev_features_t features)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
@@ -216,6 +219,7 @@ static netdev_features_t ipoib_fix_featu
 	}
 	return features;
 }
+#endif
 
 static int ipoib_change_mtu(struct net_device *dev, int new_mtu)
 {
@@ -263,10 +267,21 @@ static bool ipoib_is_dev_match_addr_rcu(
 		in_dev = in_dev_get(dev);
 		if (!in_dev)
 			return false;
-
+#ifdef HAVE_INET_CONFIRM_ADDR_EXPORTED
+#ifdef HAVE_INET_CONFIRM_ADDR_5_PARAMS
 		ret_addr = inet_confirm_addr(net, in_dev, 0,
 					     addr_in->sin_addr.s_addr,
 					     RT_SCOPE_HOST);
+#else
+		ret_addr = inet_confirm_addr(in_dev, 0,
+					     addr_in->sin_addr.s_addr,
+					     RT_SCOPE_HOST);
+#endif
+#else
+		ret_addr = confirm_addr_indev(in_dev, 0,
+					      addr_in->sin_addr.s_addr,
+					      RT_SCOPE_HOST);
+#endif
 		in_dev_put(in_dev);
 		if (ret_addr)
 			return true;
@@ -320,7 +335,9 @@ static struct net_device *ipoib_get_net_
 {
 	struct net_device *upper,
 			  *result = NULL;
+#ifdef HAVE_NETDEV_FOR_EACH_ALL_UPPER_DEV_RCU
 	struct list_head *iter;
+#endif
 
 	rcu_read_lock();
 	if (ipoib_is_dev_match_addr_rcu(addr, dev)) {
@@ -329,6 +346,7 @@ static struct net_device *ipoib_get_net_
 		goto out;
 	}
 
+#ifdef HAVE_NETDEV_FOR_EACH_ALL_UPPER_DEV_RCU
 	netdev_for_each_all_upper_dev_rcu(dev, upper, iter) {
 		if (ipoib_is_dev_match_addr_rcu(addr, upper)) {
 			dev_hold(upper);
@@ -336,6 +354,15 @@ static struct net_device *ipoib_get_net_
 			break;
 		}
 	}
+#else
+	for_each_netdev(&init_net, upper) {
+		if (ipoib_is_dev_match_addr_rcu(addr, upper)) {
+			dev_hold(upper);
+			result = upper;
+			break;
+		}
+	}
+#endif
 out:
 	rcu_read_unlock();
 	return result;
@@ -484,7 +511,11 @@ int ipoib_set_mode(struct net_device *de
 		set_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
 		ipoib_warn(priv, "enabling connected mode "
 			   "will cause multicast packet drops\n");
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 		netdev_update_features(dev);
+#else
+		dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO);
+#endif
 		dev_set_mtu(dev, ipoib_cm_max_mtu(dev));
 		rtnl_unlock();
 		priv->tx_wr.wr.send_flags &= ~IB_SEND_IP_CSUM;
@@ -497,7 +528,19 @@ int ipoib_set_mode(struct net_device *de
 
 	if (!strcmp(buf, "datagram\n")) {
 		clear_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 		netdev_update_features(dev);
+#else
+		if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM)
+			dev->features |= NETIF_F_IP_CSUM;
+
+		if (priv->max_send_sge > 1)
+			dev->features |= NETIF_F_SG;
+
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			if (dev->features & (NETIF_F_IP_CSUM | NETIF_F_SG))
+				dev->features |= NETIF_F_TSO;
+#endif
 		dev_set_mtu(dev, min(priv->mcast_mtu, dev->mtu));
 		rtnl_unlock();
 		ipoib_flush_paths(dev);
@@ -1301,6 +1344,7 @@ static void ipoib_set_mcast_list(struct
 	queue_work(priv->wq, &priv->restart_task);
 }
 
+#ifdef HAVE_NDO_GET_IFLINK
 static int ipoib_get_iflink(const struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
@@ -1312,6 +1356,76 @@ static int ipoib_get_iflink(const struct
 	/* child/vlan interface */
 	return priv->parent->ifindex;
 }
+#endif
+
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static int get_skb_hdr(struct sk_buff *skb, void **iphdr,
+		       void **tcph, u64 *hdr_flags, void *priv)
+{
+	unsigned int ip_len;
+	struct iphdr *iph;
+
+	if (unlikely(skb->protocol != htons(ETH_P_IP)))
+		return -1;
+
+	/*
+	* In the future we may add an else clause that verifies the
+	* checksum and allows devices which do not calculate checksum
+	* to use LRO.
+	*/
+	if (unlikely(skb->ip_summed != CHECKSUM_UNNECESSARY))
+		return -1;
+
+	/* Check for non-TCP packet */
+	skb_reset_network_header(skb);
+	iph = ip_hdr(skb);
+	if (iph->protocol != IPPROTO_TCP)
+		return -1;
+
+	ip_len = ip_hdrlen(skb);
+	skb_set_transport_header(skb, ip_len);
+	*tcph = tcp_hdr(skb);
+
+	/* check if IP header and TCP header are complete */
+	if (ntohs(iph->tot_len) < ip_len + tcp_hdrlen(skb))
+		return -1;
+
+	*hdr_flags = LRO_IPV4 | LRO_TCP;
+	*iphdr = iph;
+
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static void ipoib_lro_setup(struct ipoib_dev_priv *priv)
+{
+	priv->lro.lro_mgr.max_aggr		= IPOIB_LRO_MAX_AGGR;
+	priv->lro.lro_mgr.max_desc		= IPOIB_MAX_LRO_DESCRIPTORS;
+	priv->lro.lro_mgr.lro_arr		= priv->lro.lro_desc;
+	priv->lro.lro_mgr.get_skb_header	= get_skb_hdr;
+	priv->lro.lro_mgr.features		= LRO_F_NAPI;
+	priv->lro.lro_mgr.dev			= priv->dev;
+	priv->lro.lro_mgr.ip_summed_aggr	= CHECKSUM_UNNECESSARY;
+}
+#endif
+
+void set_lro_features_bit(struct ipoib_dev_priv *priv)
+{
+	u64 hw_support_lro = 0;
+#ifdef HAVE_NETDEV_HW_FEATURES
+	hw_support_lro = priv->dev->hw_features & NETIF_F_RXCSUM;
+#else
+	hw_support_lro = (priv->dev->features & NETIF_F_RXCSUM);
+#endif
+	if (hw_support_lro) {
+		priv->dev->features |= NETIF_F_LRO;
+#ifdef HAVE_NETDEV_HW_FEATURES
+		priv->dev->hw_features |= NETIF_F_LRO;
+		priv->dev->wanted_features |= NETIF_F_LRO;
+#endif
+	}
+}
+#endif
 
 static u32 ipoib_addr_hash(struct ipoib_neigh_hash *htbl, u8 *daddr)
 {
@@ -1766,6 +1880,10 @@ int ipoib_dev_init(struct net_device *de
 		goto out_rx_ring_cleanup;
 	}
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	ipoib_lro_setup(priv);
+#endif
+
 	/* priv->tx_head, tx_tail & tx_outstanding are already 0 */
 
 	if (ipoib_ib_dev_init(dev, ca, port))
@@ -1825,9 +1943,16 @@ void ipoib_dev_cleanup(struct net_device
 		/* Stop GC on child */
 		set_bit(IPOIB_STOP_NEIGH_GC, &cpriv->flags);
 		cancel_delayed_work(&cpriv->neigh_reap_task);
+#ifdef HAVE_UNREGISTER_NETDEVICE_QUEUE
 		unregister_netdevice_queue(cpriv->dev, &head);
 	}
 	unregister_netdevice_many(&head);
+#else
+	}
+
+	list_for_each_entry_safe(cpriv, tcpriv, &priv->child_intfs, list)
+		unregister_netdevice(cpriv->dev);
+#endif
 
 	/*
 	 * Must be before ipoib_ib_dev_cleanup or we delete an in use
@@ -1844,12 +1969,14 @@ void ipoib_dev_cleanup(struct net_device
 	priv->tx_ring = NULL;
 }
 
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 static int ipoib_set_vf_link_state(struct net_device *dev, int vf, int link_state)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 
 	return ib_set_vf_link_state(priv->ca, vf, priv->port, link_state);
 }
+#endif
 
 static int ipoib_get_vf_config(struct net_device *dev, int vf,
 			       struct ifla_vf_info *ivf)
@@ -1866,6 +1993,7 @@ static int ipoib_get_vf_config(struct ne
 	return 0;
 }
 
+#ifdef HAVE_NDO_SET_VF_GUID
 static int ipoib_set_vf_guid(struct net_device *dev, int vf, u64 guid, int type)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
@@ -1875,7 +2003,9 @@ static int ipoib_set_vf_guid(struct net_
 
 	return ib_set_vf_guid(priv->ca, vf, priv->port, guid, type);
 }
+#endif
 
+#ifdef HAVE_NDO_GET_VF_STATS
 static int ipoib_get_vf_stats(struct net_device *dev, int vf,
 			      struct ifla_vf_stats *vf_stats)
 {
@@ -1883,6 +2013,7 @@ static int ipoib_get_vf_stats(struct net
 
 	return ib_get_vf_stats(priv->ca, vf, priv->port, vf_stats);
 }
+#endif
 
 static const struct header_ops ipoib_header_ops = {
 	.create	= ipoib_hard_header,
@@ -1893,17 +2024,29 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit		 = ipoib_start_xmit,
 	.ndo_tx_timeout		 = ipoib_timeout,
 	.ndo_get_stats		 = NULL, /* TODO */
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 	.ndo_set_vf_link_state	 = ipoib_set_vf_link_state,
+#endif
 	.ndo_get_vf_config	 = ipoib_get_vf_config,
+#ifdef HAVE_NDO_GET_VF_STATS
 	.ndo_get_vf_stats	 = ipoib_get_vf_stats,
+#endif
+#ifdef HAVE_NDO_SET_VF_GUID
 	.ndo_set_vf_guid	 = ipoib_set_vf_guid,
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 	.ndo_set_mac_address	 = ipoib_set_mac,
+#endif
 };
 
 static const struct net_device_ops ipoib_netdev_ops_vf = {
@@ -1911,12 +2054,16 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit	 	 = ipoib_start_xmit,
 	.ndo_tx_timeout		 = ipoib_timeout,
 	.ndo_get_stats		 = NULL, /* TODO */
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
 };
 
 void ipoib_setup(struct net_device *dev)
@@ -2063,6 +2210,7 @@ static void set_base_guid(struct ipoib_d
 	}
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 static int ipoib_check_lladdr(struct net_device *dev,
 			      struct sockaddr_storage *ss)
 {
@@ -2088,11 +2236,14 @@ static int ipoib_set_mac(struct net_devi
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct sockaddr_storage *ss = addr;
-	int ret;
+	int ret = 0;
 
+#if defined HAVE_NETDEV_IFF_LIVE_ADDR_CHANGE
 	if (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))
+#else
+	if (!netif_running(dev))
 		return -EBUSY;
-
+#endif
 	ret = ipoib_check_lladdr(dev, ss);
 	if (ret)
 		return ret;
@@ -2103,6 +2254,7 @@ static int ipoib_set_mac(struct net_devi
 
 	return 0;
 }
+#endif
 
 static ssize_t ipoib_set_mac_using_sysfs(struct device *dev,
 					 struct device_attribute *attr,
@@ -2176,14 +2328,20 @@ int ipoib_set_dev_features(struct ipoib_
 	ipoib_get_hca_features(priv, hca);
 
 	if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM) {
+#ifdef HAVE_NETDEV_HW_FEATURES
 		priv->dev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
 
 		if (priv->hca_caps & IB_DEVICE_UD_TSO)
 			priv->dev->hw_features |= NETIF_F_TSO;
 
 		priv->dev->features |= priv->dev->hw_features;
-	}
+#else
+		priv->dev->features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
 
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			priv->dev->features |= NETIF_F_TSO;
+#endif
+	}
 	return 0;
 }
 
@@ -2228,9 +2386,9 @@ static struct net_device *ipoib_add_port
 	/* MTU will be reset when mcast join happens */
 	priv->dev->mtu  = IPOIB_UD_MTU(priv->max_ib_mtu);
 	priv->mcast_mtu  = priv->admin_mtu = priv->dev->mtu;
-
+#if defined HAVE_NET_DEVICE_NEIGH_PRIV_LEN
 	priv->dev->neigh_priv_len = sizeof(struct ipoib_neigh);
-
+#endif
 	result = ib_query_pkey(hca, port, 0, &priv->pkey);
 	if (result) {
 		printk(KERN_WARNING "%s: ib_query_pkey port %d failed (ret = %d)\n",
@@ -2284,6 +2442,13 @@ static struct net_device *ipoib_add_port
 		goto register_failed;
 	}
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	/* force lro on the dev->features, because the function
+	 * register_netdev disable it according to our private lro
+	 */
+	set_lro_features_bit(priv);
+#endif
+
 	ipoib_create_debug_files(priv->dev);
 
 	if (ipoib_cm_add_mode_attr(priv->dev))
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@ -888,7 +888,11 @@ void ipoib_mcast_restart_task(struct wor
 	struct ipoib_dev_priv *priv =
 		container_of(work, struct ipoib_dev_priv, restart_task);
 	struct net_device *dev = priv->dev;
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
 	struct ipoib_mcast *mcast, *tmcast;
 	LIST_HEAD(remove_list);
 	unsigned long flags;
@@ -918,14 +922,25 @@ void ipoib_mcast_restart_task(struct wor
 		clear_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);
 
 	/* Mark all of the entries that are found or don't exist */
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 	netdev_for_each_mc_addr(ha, dev) {
+#else
+		for (mclist = dev->mc_list; mclist; mclist = mclist->next) {
+#endif
+
 		union ib_gid mgid;
 
+#ifdef HAVE_NETDEV_FOR_EACH_MC_ADDR
 		if (!ipoib_mcast_addr_is_valid(ha->addr, dev->broadcast))
 			continue;
 
 		memcpy(mgid.raw, ha->addr + 4, sizeof mgid);
+#else
+		if (!ipoib_mcast_addr_is_valid(mclist->dmi_addr, dev->broadcast))
+			continue;
 
+		memcpy(mgid.raw, mclist->dmi_addr + 4, sizeof mgid);
+#endif
 		mcast = __ipoib_mcast_find(dev, &mgid);
 		if (!mcast || test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {
 			struct ipoib_mcast *nmcast;
--- a/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_netlink.c
@@ -92,8 +92,12 @@ out_err:
 	return ret;
 }
 
+#ifdef HAVE_RTNL_LINK_OPS_NEWLINK_4_PARAMS
 static int ipoib_new_child_link(struct net *src_net, struct net_device *dev,
-			       struct nlattr *tb[], struct nlattr *data[])
+#else
+static int ipoib_new_child_link(struct net_device *dev,
+#endif
+				struct nlattr *tb[], struct nlattr *data[])
 {
 	struct net_device *pdev;
 	struct ipoib_dev_priv *ppriv;
@@ -102,8 +106,12 @@ static int ipoib_new_child_link(struct n
 
 	if (!tb[IFLA_LINK])
 		return -EINVAL;
-
+#ifdef HAVE_RTNL_LINK_OPS_NEWLINK_4_PARAMS
 	pdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));
+#else
+	pdev = __dev_get_by_index(dev_net(dev), nla_get_u32(tb[IFLA_LINK]));
+#endif
+
 	if (!pdev || pdev->type != ARPHRD_INFINIBAND)
 		return -ENODEV;
 
@@ -136,7 +144,11 @@ static int ipoib_new_child_link(struct n
 	return err;
 }
 
+#ifdef HAVE_RTNL_LINK_OPS_DELLINK_2_PARAMS
 static void ipoib_unregister_child_dev(struct net_device *dev, struct list_head *head)
+#else
+static void ipoib_unregister_child_dev(struct net_device *dev)
+#endif
 {
 	struct ipoib_dev_priv *priv, *ppriv;
 
@@ -144,7 +156,11 @@ static void ipoib_unregister_child_dev(s
 	ppriv = netdev_priv(priv->parent);
 
 	down_write(&ppriv->vlan_rwsem);
+#ifdef HAVE_RTNL_LINK_OPS_DELLINK_2_PARAMS
 	unregister_netdevice_queue(dev, head);
+#else
+	unregister_netdevice(dev);
+#endif
 	list_del(&priv->list);
 	up_write(&ppriv->vlan_rwsem);
 }
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ethtool_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ethtool_rss.c
@@ -143,7 +143,7 @@ static int ipoib_get_sset_count_rss(stru
 	}
 	return -EOPNOTSUPP;
 }
-
+#ifdef HAVE_GET_SET_CHANNELS
 static void ipoib_get_channels(struct net_device *dev,
 			       struct ethtool_channels *channel)
 {
@@ -202,6 +202,7 @@ static int ipoib_set_channels(struct net
 
 	return ipoib_reinit_rss(dev, channel->rx_count, channel->tx_count);
 }
+#endif
 
 static const struct ethtool_ops ipoib_ethtool_ops_rss = {
 	.get_drvinfo		= ipoib_get_drvinfo,
@@ -212,10 +213,29 @@ static const struct ethtool_ops ipoib_et
 	.get_strings		= ipoib_get_strings_rss,
 	.get_ethtool_stats	= ipoib_get_ethtool_stats_rss,
 	.get_sset_count		= ipoib_get_sset_count_rss,
+#ifdef HAVE_GET_SET_CHANNELS
 	.get_channels		= ipoib_get_channels,
 	.set_channels		= ipoib_set_channels,
+#endif
 	.set_ringparam		= ipoib_set_ring_param,
 	.get_ringparam		= ipoib_get_ring_param,
+
+/* IPoIB current code supports HW_FEATURES and doesn't
+ * support EXTENDED_HW_FEATURES. If support for EXTENDED_HW_FEATURES
+ * is added then this code and the set function should be masked
+ * with LEGACY_ETHTOOL_OPS.
+ */
+#ifndef HAVE_NETDEV_HW_FEATURES
+#ifdef HAVE_GET_SET_FLAGS
+#if defined (CONFIG_COMPAT_LRO_ENABLED_IPOIB)
+	.set_flags		= ipoib_set_flags,
+#endif
+	.get_flags		= ethtool_op_get_flags,
+#endif
+#ifdef HAVE_GET_SET_TSO
+	.set_tso		= ethtool_op_set_tso,
+#endif
+#endif
 };
 
 static const struct ethtool_ops *ipoib_ethtool_ops_select;
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_ib_rss.c
@@ -230,9 +230,14 @@ static void ipoib_ib_handle_rx_wc_rss(st
 	if ((dev->features & NETIF_F_RXCSUM) &&
 			likely(wc->wc_flags & IB_WC_IP_CSUM_OK))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
-
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	if (dev->features & NETIF_F_LRO)
+		lro_receive_skb(&recv_ring->lro.lro_mgr, skb, NULL);
+	else
+		netif_receive_skb(skb);
+#else
 	napi_gro_receive(&recv_ring->napi, skb);
-
+#endif
 repost:
 	if (unlikely(ipoib_ib_post_receive_rss(dev, recv_ring, wr_id)))
 		ipoib_warn(priv, "ipoib_ib_post_receive_rss failed "
@@ -333,6 +338,10 @@ poll_more:
 	}
 
 	if (done < budget) {
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		if (dev->features & NETIF_F_LRO)
+			lro_flush_all(&rx_ring->lro.lro_mgr);
+#endif
 		napi_complete(napi);
 		if (unlikely(ib_req_notify_cq(rx_ring->recv_cq,
 					      IB_CQ_NEXT_COMP |
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_main_rss.c
@@ -51,7 +51,11 @@ int ipoib_set_mode_rss(struct net_device
 		set_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
 		ipoib_warn(priv, "enabling connected mode "
 			   "will cause multicast packet drops\n");
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)  
 		netdev_update_features(dev);
+#else
+		dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO);
+#endif
 		dev_set_mtu(dev, ipoib_cm_max_mtu(dev));
 		rtnl_unlock();
 
@@ -69,7 +73,19 @@ int ipoib_set_mode_rss(struct net_device
 
 	if (!strcmp(buf, "datagram\n")) {
 		clear_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);
+#if defined (HAVE_NETDEV_UPDATE_FEATURES) && defined (HAVE_NDO_FIX_FEATURES)
 		netdev_update_features(dev);
+#else
+		if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM)
+			dev->features |= NETIF_F_IP_CSUM;
+
+		if (priv->max_send_sge > 1)
+			dev->features |= NETIF_F_SG;
+
+		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+			if (dev->features & (NETIF_F_IP_CSUM | NETIF_F_SG))
+				dev->features |= NETIF_F_TSO;
+#endif
 		dev_set_mtu(dev, min(priv->mcast_mtu, dev->mtu));
 		rtnl_unlock();
 		ipoib_flush_paths(dev);
@@ -81,9 +97,16 @@ int ipoib_set_mode_rss(struct net_device
 	return -EINVAL;
 }
 
+#if defined(NDO_SELECT_QUEUE_HAS_ACCEL_PRIV) || defined(HAVE_SELECT_QUEUE_FALLBACK_T)
 static u16 ipoib_select_queue_sw_rss(struct net_device *dev, struct sk_buff *skb,
-				     void *accel_priv,
-				     select_queue_fallback_t fallback)
+#ifdef HAVE_SELECT_QUEUE_FALLBACK_T
+				     void *accel_priv, select_queue_fallback_t fallback)
+#else
+				     void *accel_priv)
+#endif
+#else /* NDO_SELECT_QUEUE_HAS_ACCEL_PRIV || HAVE_SELECT_QUEUE_FALLBACK_T */
+static u16 ipoib_select_queue_sw_rss(struct net_device *dev, struct sk_buff *skb)
+#endif
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct ipoib_pseudo_header *phdr;
@@ -221,6 +244,20 @@ static struct ipoib_neigh *ipoib_neigh_c
 	return neigh;
 }
 
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+static void ipoib_lro_setup_rss(struct ipoib_recv_ring *recv_ring,
+				struct ipoib_dev_priv *priv)
+{
+	recv_ring->lro.lro_mgr.max_aggr  = IPOIB_LRO_MAX_AGGR;
+	recv_ring->lro.lro_mgr.max_desc  = IPOIB_MAX_LRO_DESCRIPTORS;
+	recv_ring->lro.lro_mgr.lro_arr   = recv_ring->lro.lro_desc;
+	recv_ring->lro.lro_mgr.get_skb_header = get_skb_hdr;
+	recv_ring->lro.lro_mgr.features  = LRO_F_NAPI;
+	recv_ring->lro.lro_mgr.dev               = priv->dev;
+	recv_ring->lro.lro_mgr.ip_summed_aggr = CHECKSUM_UNNECESSARY;
+}
+#endif
+
 int ipoib_dev_init_rss(struct net_device *dev, struct ib_device *ca, int port)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
@@ -251,6 +288,9 @@ int ipoib_dev_init_rss(struct net_device
 		}
 		recv_ring->dev = dev;
 		recv_ring->index = i;
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+		ipoib_lro_setup_rss(recv_ring, priv);
+#endif
 		recv_ring++;
 		rx_allocated++;
 	}
@@ -358,6 +398,7 @@ void ipoib_dev_cleanup_rss(struct net_de
 		/* Stop GC on child */
 		set_bit(IPOIB_STOP_NEIGH_GC, &cpriv->flags);
 		cancel_delayed_work(&cpriv->neigh_reap_task);
+#ifdef HAVE_UNREGISTER_NETDEVICE_QUEUE
 		unregister_netdevice_queue(cpriv->dev, &head);
 	}
 	/*
@@ -365,7 +406,12 @@ void ipoib_dev_cleanup_rss(struct net_de
 	 * ipoib_dev_cleanup_rss for each devices at the head list.
 	 */
 	unregister_netdevice_many(&head);
+#else
+	}
 
+	list_for_each_entry_safe(cpriv, tcpriv, &priv->child_intfs, list)
+		unregister_netdevice(cpriv->dev);
+#endif
 	ipoib_dev_uninit_rss(dev);
 	up_write(&priv->rings_rwsem);
 }
@@ -718,18 +764,30 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit		 = ipoib_start_xmit_rss,
 	.ndo_select_queue	 = ipoib_select_queue_sw_rss,
 	.ndo_tx_timeout		 = ipoib_timeout_rss,
 	.ndo_get_stats		 = ipoib_get_stats_rss,
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
+#ifdef HAVE_NETDEV_OPS_NDO_SET_VF_LINK_STATE
 	.ndo_set_vf_link_state	 = ipoib_set_vf_link_state,
+#endif
 	.ndo_get_vf_config	 = ipoib_get_vf_config,
+#ifdef HAVE_NDO_GET_VF_STATS
 	.ndo_get_vf_stats	 = ipoib_get_vf_stats,
+#endif
+#ifdef HAVE_NDO_SET_VF_GUID
 	.ndo_set_vf_guid	 = ipoib_set_vf_guid,
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 7, 0)
 	.ndo_set_mac_address	 = ipoib_set_mac,
+#endif
 };
 
 static const struct net_device_ops ipoib_netdev_ops_vf_sw_tss = {
@@ -737,13 +795,17 @@ static const struct net_device_ops ipoib
 	.ndo_open		 = ipoib_open,
 	.ndo_stop		 = ipoib_stop,
 	.ndo_change_mtu		 = ipoib_change_mtu,
+#ifdef HAVE_NDO_FIX_FEATURES
 	.ndo_fix_features	 = ipoib_fix_features,
+#endif
 	.ndo_start_xmit	 	 = ipoib_start_xmit_rss,
 	.ndo_select_queue 	 = ipoib_select_queue_sw_rss,
 	.ndo_tx_timeout		 = ipoib_timeout_rss,
 	.ndo_get_stats		 = ipoib_get_stats_rss,
 	.ndo_set_rx_mode	 = ipoib_set_mcast_list,
+#ifdef HAVE_NDO_GET_IFLINK
 	.ndo_get_iflink		 = ipoib_get_iflink,
+#endif
 };
 
 static const struct net_device_ops *ipoib_netdev_ops_select;
--- a/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h
+++ b/drivers/infiniband/ulp/ipoib/rss_tss/ipoib_rss.h
@@ -100,6 +100,9 @@ struct ipoib_recv_ring {
 	struct ipoib_rx_cm_info	cm;
 	struct ipoib_rx_ring_stats stats;
 	unsigned		index;
+#ifdef CONFIG_COMPAT_LRO_ENABLED_IPOIB
+	struct ipoib_lro lro;
+#endif
 };
 
 static inline void ipoib_build_sge_rss(struct ipoib_send_ring *send_ring,
